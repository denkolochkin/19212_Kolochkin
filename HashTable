#include <iostream>
#include <math.h>

using namespace std;



// В этой задаче для простоты не требуется делать контейнер шаблонным,
// это допускается по желанию. Для нешаблонного решения,
// введем типы ключей и значений: ключом будет выступать строка (например, имя
// студента, значением - произвольная структура (например, численные
// характеристики студента.
typedef std::string Key;

struct Value {
  unsigned age;
  unsigned weight;
};

class HashTable
{
public:

  HashTable() {
      table_size = 17;
      current_table_size = 1;
      fill_factor = static_cast<float>(current_table_size)/static_cast<float>(table_size);

      for (int i = 0; i < table_size; ++i) {
          nodes[i] = nullptr;
      }

  };

  ~HashTable(){};

  typedef struct node {
      string Key;
      Value value;
      node* next;
  }node;

  node** nodes = new node*;

  HashTable(const HashTable& b);
  // Обменивает значения двух хэш-таблиц.
  // Подумайте, зачем нужен этот метод, при наличии стандартной функции
  // std::swap.
  void swap(HashTable& b);

  HashTable& operator=(const HashTable& b) {};

  // Очищает контейнер.
  void clear();
  // Удаляет элемент по заданному ключу.
  bool erase(const Key& k);

  // Вставка в контейнер. Возвращаемое значение - успешность вставки.
  bool insert(const Key& k, const Value& value) {
      /*todo resize of table*/
      int index = get_hash(k, current_table_size);
      if(nodes[index] != nullptr) {
          nodes[index]->next = new node;
          nodes[index]->next->Key = k;
          nodes[index]->next->value = value;
          nodes[index]->next->next = nullptr;
      } else {
          nodes[index] = new node;
          nodes[index]->Key = k;
          nodes[index]->value = value;
          nodes[index]->next = nullptr;
      }
      current_table_size++;
  };

  // Проверка наличия значения по заданному ключу.
   bool contains(const Key& k) {
      int index;
      index = get_hash(k, current_table_size);
      if (nodes[index] != nullptr) {
          if (nodes[index]->Key == k) return true;
            else {
                while (nodes[index] != nullptr) {
                    nodes[index] = nodes[index]->next;
                    if (nodes[index]->Key == k) return true;
                }
            }
      } else return false;
  };

  // Возвращает значение по ключу. Небезопасный метод.
  // В случае отсутствия ключа в контейнере, следует вставить в контейнер
  // значение, созданное конструктором по умолчанию и вернуть ссылку на него.
  Value& operator[](const Key& k);

  // Возвращает значение по ключу. Бросает исключение при неудаче.
  Value& at(const Key& k);
  const Value& at(const Key& k) const;

  size_t size() const {
      return table_size;
  };
  bool empty() const{
      if (table_size == 0) return true;
        else return false;
  };

  friend bool operator==(const HashTable& a, const HashTable& b);
  friend bool operator!=(const HashTable& a, const HashTable& b);

  int get_hash(const string& key, int& current_table_size) {
       int hash_result = 0;
       for (int i = 0; key[i] != 0; ++i) {
            hash_result += key[i] % table_size;
       }
       hash_result = (hash_result*2 + 1) % table_size;
       return hash_result;
  }

private:
    int table_size;
    int current_table_size;
    float fill_factor;
 };



bool test() {
    HashTable a;
    string key = "lorem";
    Value value;
    value.age = 19;
    value.weight = 170;
    a.insert(key, value);
    assert(a.contains("lorem"));
}


int main() {
    test();
    return 0;
}
